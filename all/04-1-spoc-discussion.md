#lec8: 虚拟内存spoc练习


NOTICE
- 有"w4l2"标记的题是助教要提交到学堂在线上的。
- 有"w4l2"和"spoc"标记的题是要求拿清华学分的同学要在实体课上完成，并按时提交到学生对应的git repo上。
- 有"hard"标记的题有一定难度，鼓励实现。
- 有"easy"标记的题很容易实现，鼓励实现。
- 有"midd"标记的题是一般水平，鼓励实现。

提前准备

- 完成lec8的视频学习和提交对应的在线练习
- git pull uco
re_os_lab, v9_cpu, os_course_spoc_exercises 　in github repos。这样可以在本机上完成课堂练习。
- 理解如何实现建立页表，给用户态建立页表，在用户态使用虚地址，产生各自也访问错误的基本应对

## 视频相关思考题
### 8.1 虚拟存储的需求背景

1. 寄存器、高速缓存、内存、外存的访问特征？

2. 如何理解计算机中的存储层次结构所的理想状态是“均衡繁忙”状态？

3. 在你写程序时遇到过内存不够的情况吗？尝试过什么解决方法？

### 8.2 覆盖和交换

1. 什么是覆盖技术？使用覆盖技术的程序开发者的主要工作是什么？

2. 什么是交换技术？覆盖与交换有什么不同？

3. 覆盖和交换技术在现代计算机系统中还有需要吗？可能用在什么地方？

4. 如何分析内核模块间的依赖关系？

5. 如何获取内核模块间的函数调用列表？


### 8.3 局部性原理

1. 什么是时间局部性、空间局部性和分支局部性？

2. 如何提高程序执行时的局部性特征？



3. 排序算法的局部性特征？
  * 参考：[九大排序算法再总结](http://blog.csdn.net/xiazdong/article/details/8462393)

### 8.4 虚拟存储概念

1. 什么是虚拟存储？它与覆盖和交换的区别是什么？它有什么好处和挑战？

2. 虚拟存储需要什么样的支持技术？


### 8.5 虚拟页式存储

 1. 什么是虚拟页式存储？缺页中断处理的功能是什么？

 1. 为了支持虚拟页式存储的实现，页表项有什么修改？


 2. 页式存储和虚拟页式存储的区别是什么？

### 8.6 缺页异常

1. 缺页异常的处理流程？


2. 虚拟页式存储管理中有效存储访问时间是如何计算的？


## 个人思考题

### 内存访问局部性的应用程序例子
---
(1)(w4l2)下面是一个体现内存访问局部性好的简单应用程序例子，请参考，在linux中写一个简单应用程序，体现内存局部性差，并给出其执行时间。
```
#include <stdio.h>
#define NUM 1024
#define COUNT 10
int A[NUM][NUM];
void main (void) {
  int i,j,k;
  for (k = 0; k<COUNT; k++)
  for (i = 0; i < NUM; i++)
  for (j = 0; j	 < NUM; j++)
      A[i][j] = i+j;
  printf("%d count computing over!\n",i*j*k);
}
```
可以用下的命令来编译和运行此程序：
```
gcc -O0 -o goodlocality goodlocality.c
time ./goodlocality
```
可以看到其执行时间。

## 小组思考题目
----

### 缺页异常嵌套

（1）缺页异常可用于虚拟内存管理中。如果在中断服务例程中进行缺页异常的处理时，再次出现缺页异常，这时计算机系统（软件或硬件）会如何处理？请给出你的合理设计和解释。

> 提示：https://en.wikipedia.org/wiki/Double_fault 和 https://en.wikipedia.org/wiki/Triple_fault

### 缺页异常次数计算
（2）如果80386机器的一条机器指令(指字长4个字节)，其功能是把一个32位字的数据装入寄存器，指令本身包含了要装入的字所在的32位地址。这个过程在OS合理处理情况下最多会引起几次缺页异常？
> 提示：内存中的指令和数据的地址需要考虑地址对齐和不对齐两种情况。需要考虑页目录表项invalid、页表项invalid、TLB缺失等是否会产生异常？

### 虚拟页式存储的地址转换

（3）(spoc) 有一台假想的计算机，页大小（page size）为32 Bytes，支持8KB的虚拟地址空间（virtual address space）,有4KB的物理内存空间（physical memory），采用二级页表，一个页目录项（page directory entry ，PDE）大小为1 Byte,一个页表项（page-table entries
PTEs）大小为1 Byte，1个页目录表大小为32 Bytes，1个页表大小为32 Bytes。页目录基址寄存器（page directory base register，PDBR）保存了页目录表的物理地址（按页对齐）。

PTE格式（8 bit） :
```
  VALID | PFN6 ... PFN0
```
PDE格式（8 bit） :
```
  VALID | PT6 ... PT0
```
其
```
VALID==1表示，表示映射存在；VALID==0表示，表示内存映射不存在（有两种情况：a.对应的物理页帧swap out在硬盘上；b.既没有在内存中，页没有在硬盘上，这时页帧号为0x7F）。
PFN6..0:页帧号或外存中的后备页号
PT6..0:页表的物理基址>>5
```

已经建立好了1个页目录表和8个页表，且页目录表的index为0~7的页目录项分别对应了这8个页表。

在[物理内存模拟数据文件](./04-1-spoc-memdiskdata.md)中，给出了4KB物理内存空间和4KBdisk空间的值，PDBR的值。

请手工计算后回答下列虚地址是否有合法对应的物理内存，请给出对应的pde index, pde contents, pte index, pte contents，the value of addr in phy page OR disk sector。
```
1) Virtual Address 6653:
2) Virtual Address 1c13:
3) Virtual Address 6890:
4) Virtual Address 0af6:
5) Virtual Address 1e6f:
```

请写出一个translation程序（可基于rust、python、ruby、C、C++、LISP、JavaScript等），输入是一个虚拟地址，依据[物理内存模拟数据文件](./04-1-spoc-memdiskdata.md)自动计算出对应的pde index, pde contents, pte index, pte contents，the value of addr in phy page OR disk sector。

**提示:**
```
页大小（page size）为32 Bytes(2^5)
页表项1B

8KB的虚拟地址空间(2^13)
一级页表：2^5
PDBR content: 0xd80（1101_100 0_0000, page 0x6c）

page 6c: e1(1110 0001) b5(1011 0101) a1(1010 0001) c1(1100 0001)
         b3(1011 0011) e4(1110 0100) a6(1010 0110) bd(1011 1101)
二级页表：2^5
页内偏移：2^5

4KB的物理内存空间（physical memory）(2^12)
物理帧号：2^7

Virtual Address 0330(0 00000 11001 1_0000):
  --> pde index:0x0(00000)  pde contents:(0xe1, 11100001, valid 1, pfn 0x61(page 0x61))
  page 6c: e1 b5 a1 c1 b3 e4 a6 bd 7f 7f 7f 7f 7f 7f 7f 7f
           7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f
  page 61: 7c 7f 7f 4e 4a 7f 3b 5a 2a be 7f 6d 7f 66 7f a7
           69 96 7f c8 3a 7f a5 83 07 e3 7f 37 62 30 7f 3f
    --> pte index:0x19(11001)  pte contents:(0xe3, 1 110_0011, valid 1, pfn 0x63)
  page 63: 16 00 0d 15 00 1c 1d 16 02 02 0b 00 0a 00 1e 19
           02 1b 06 06 14 1d 03 00 0b 00 12 1a 05 03 0a 1d
      --> To Physical Address 0xc70(110001110000, 0xc70) --> Value: 02

Virtual Address 1e6f(0 001_11 10_011 0_1111):
  --> pde index:0x7(00111)  pde contents:(0xbd, 10111101, valid 1, pfn 0x3d)
  page 6c: e1 b5 a1 c1 b3 e4 a6 bd 7f 7f 7f 7f 7f 7f 7f 7f
           7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f
  page 3d: f6 7f 5d 4d 7f 04 29 7f 1e 7f ef 51 0c 1c 7f 7f
           7f 76 d1 16 7f 17 ab 55 9a 65 ba 7f 7f 0b 7f 7f
    --> pte index:0x13  pte contents:(0x16, valid 0, pfn 0x16)
  disk 16: 00 0a 15 1a 03 00 09 13 1c 0a 18 03 13 07 17 1c
           0d 15 0a 1a 0c 12 1e 11 0e 02 1d 10 15 14 07 13
      --> To Disk Sector Address 0x2cf(0001011001111) --> Value: 1c
```

## 扩展思考题
---
(1)请分析原理课的缺页异常的处理流程与lab3中的缺页异常的处理流程（分析粒度到函数级别）的异同之处。

(2)在X86-32虚拟页式存储系统中，假定第一级页表的起始地址是0xE8A3 B000，进程地址空间只有第一级页表的4KB在内存。请问这4KB的虚拟地址是多少？它对应的第一级页表项和第二级页表项的物理地址是多少？页表项的内容是什么？

## v9-cpu相关


[challenge]在v9-cpu上，设定物理内存为64MB。在os.c,os2.c,os4.c,os5的基础上实现os6.c，可体现基本虚拟内存管理机制，内核空间的映射关系： kernel_virt_addr=0xc00000000+phy_addr，内核空间大小为64MB，虚拟空间范围为0xc0000000--x0xc4000000, 物理空间范围为0x00000000--x0x04000000；用户空间的映射关系：user_virt_addr=0x40000000+usr_phy_addr，用户空间可用大小为2MB，虚拟空间范围为0x40000000--0x40200000，物理空间范围为0x02000000--x0x02200000，但只建立低地址的1MB的用户空间页表映射。可参考v9-cpu git repo的testing分支中的os.c和mem.h。修改代码为os5.c

- (1)在建立页表后，进入用户态，能够在用户态访问基于用户空间的映射关系
- (2)在用户态和内核态产生各种也访问的错误，并能够通过中断服务例程进行信息提示
- (3)内核通过中断服务例程在感知到用户态访问高地址的空间，且没有超过0x40200000时，内核动态建立页表，确保用户态程序可以正确运行



如果一个用户态进程访问一个合法用户地址，产生内存访问异常后，v9-cpu会把产生异常的pc存在哪里？中断服务例程应该如何设计，可以返回到用户态产生错误的地址再次执行?

## 问答题

1. 覆盖、交换和虚拟存储有何异同，虚拟存储的优势和挑战体现在什么地方？
   * 共同点：都是采取层次存储的思路，将暂时不用的内存放到外存中去，以此来缓解内存不足的问题。
   * 不同点：
     * 粒度不同：覆盖置换的单位是程序模块，交换时整个进程的内存，虚拟存储可以是一个段或者一个页。
     * 自动化程度不同：覆盖需要程序自己决定模块划分和置换时机，交换和虚拟存储可由操作系统自动完成。
   * 虚拟存储的优势：
     * 粒度合适，比较灵活。兼顾了覆盖和交换的好处：可以在较小粒度上置换；自动化程度高，编程简单，受程序本身影响很小。（覆盖的粒度受限于程序模块的大小，对编程技巧要求很高。交换粒度较大，受限于程序所需内存。尤其页式虚拟存储，几乎不受程序影响，一般情况下，只要置换算法合适，表现稳定、高效）
     * 页式虚拟存储还可以同时解决内存外碎片。提高空间利用率。
   * 虚拟存储的挑战
     * 依赖于置换算法的性能。
     * 相比于覆盖和交换，需要比较高的硬件支持。
     * 较小的粒度在面临大规模的置换时会发生多次较小规模置换，降低效率。典型情况是程序第一次执行时的大量page fault，可配合预取技术缓解这一问题。

1. 什么是局部性原理？为何很多程序具有局部性？局部性原理总是正确的吗？为何局部性原理为虚拟存储提供了性能的理论保证？
   
    局部性原理：程序执行过程中的一个较短时间内，所执行的指令地址和指令的操作数地址，分别局限于一定区域（合理即可）。分为时间、空间、分支局部性。

    指令的顺序执行、数组的连续存放、循环的多次重复是局部性原理的主要成因。

    局部性原理适用于常见的、出现较多的情况，不一定总是正确的。常见反例：视频等流式数据。
    
    局部性原理表明，在段/页大小不十分小时，程序的短期访问会集中于某一个或者某几个段/页中，缺段/页不会频繁的发生，也就不会频繁访问外存，降低效率。局部性原理为小粒度置换的性能提供了理论保证。

1. 页访问异常的成因有那些？试描述缺页异常的执行流程。
   
    成因：内存不足被换出；尚未调入内存（第一次访问）

    流程：略。视频中有详细介绍，合理即可。

1. 一条load指令，最多导致多少次页访问异常？不必纠结于答案，尝试考虑较多情况。

    指令和数据都可能缺页。

    页表缺页：MMU会首先查找页表，如果页表缺页也会出发缺页异常。这种情况下如果采用多级页表，每一级都可能发生缺页。

    不对齐访存：如果访存地址不对齐，可能导致访问两个页面。此时除了最高层页表，其余各层页表可能全部再次缺页。

1. 如果在缺页中断服务例程执行时，再次出现缺页异常，这时计算机系统（软件或硬件）会如何处理？这种情况可能出现吗？
   
    参考

    * https://piazza.com/class/i5j09fnsl7k5x0?cid=1292

    * https://piazza.com/class/i5j09fnsl7k5x0?cid=761

    * https://en.wikipedia.org/wiki/Double_fault 

    * https://en.wikipedia.org/wiki/Triple_fault    

    参考回答：

    （x86）硬件是允许 PFH 执行过程中又产生 PF 的。如果发生了这种情况，也就是发生了一次异常嵌套，处理器不会管你的异常是不是嵌套的，它只会按照标准异常处理流程，跳到处理例程。

    异常嵌套在前若干次（根据内核栈的大小，几百到几千次）都是标准的“跳到 IDT 指向的 handler、push eip/cs、读 TSS 换栈”的异常处理流程。每次嵌套，硬件和软件都会压栈，所以若干次嵌套之后会栈溢出（i.e. 到没有页表映射的地址）。这时继续嵌套，CPU 在尝试跳转到 IDT 指向的 handler 过程中发现不能压栈，因为栈溢出了，压栈会导致 page fault。也就是说，“尝试跳转到 page fault handler 的时候又触发了一个 page fault”，根据 sdm3 表 6-5 这种情况导致 CPU 触发一个 double fault 异常。触发 double fault 异常之后，处理器会按照标准流程尝试跳转到 handler 去处理这个 double fault（注意 double fault 和其他异常一样就是一个普通的异常）。但是栈已经溢出了，所以在跳转到 double fault 的时候再次发生了 page fault（硬件无法压栈 eip 等）。按照表 6-5，这种情况下处理器进入 shutdown mode。

    使用 qemu 的时候，qemu 默认检测到 cpu shutdown 之后会自动 reboot（可用参数 -no-reboot 修改这个行为）。

    可以看到，处理流程很复杂。因此，如果出现了嵌套 page fault 的情况，你应当认为你的 OS 设计/编码出错。换言之，一个 sensible 的 OS 设计要避免嵌套 page fault 的情况，例如永远不换出 PFH。

    注意给学生强调，double fault 不是说【执行】fault handler 的时候触发了 fault，而是【硬件跳转到】fault handler 的时候触发了 fault。并且 double fault 和 #DE #GP 一样就是一个异常。triple fault 才是不可恢复的重大错误，会导致关机。
   
   
1. 在页面被换出后，如何记录被换出后算在的磁盘位置？以linux系统交换区为例进行思考。
   
    对于一个页表项，在页面驻留位被置0后，其余位随之失去意义，这是可以在这些位置中存放关于磁盘位置的信息（如交换区区号，交换区内的页槽索引等）
  
1. 是否所有的页面被换出后都要置于交换区？
   
    不是。例如该数据位代码段，没有经过修改，可以直接刷掉，下次访问时再次从磁盘读取。

2. 发生page fault时，sepc、stval、scause 分别储存了那些内容？
    * sepc：发生异常时正在执行的指令地址

    * stval：发生异常时访问的地址

    * scause：发生异常的种类，缺页异常分为：instruction page fault, load page fault, store/AMO page fault   （PS:amo指令表示原子操作）